const fs = require('fs');

// Read the aiMonitoringService file
const filePath = './functions/api/services/aiMonitoringService.ts';
let content = fs.readFileSync(filePath, 'utf8');

// Find and replace the forceEngagement method with a simpler version
const methodStart = content.indexOf('async forceEngagement(): Promise<void> {');
const methodEnd = content.indexOf('async forceAnalysis(): Promise<void> {');

if (methodStart !== -1 && methodEnd !== -1) {
  const beforeMethod = content.substring(0, methodStart);
  const afterMethod = content.substring(methodEnd);
  
  const newMethod = `async forceEngagement(): Promise<void> {
    logger.info('ğŸš€ Forcing immediate engagement...')
    
    try {
      // Step 1: Process existing engagement opportunities
      logger.info('ğŸ“‹ Step 1: Processing existing engagement opportunities...')
      await this.processEngagementOpportunities()
      
      // Step 2: Always generate a proactive question
      logger.info('ğŸ¤– Step 2: Generating proactive question...')
      await this.generateProactiveQuestion()
      
    } catch (error) {
      logger.error('ğŸ’¥ Error in forceEngagement:', error)
      logger.error('Stack trace:', error.stack)
      throw error
    }
  }

  // Generate a single proactive question
  private async generateProactiveQuestion(): Promise<void> {
    try {
      logger.info('ğŸ¯ Generating proactive question...')
      
      // Generate proactive engagement
      const engagement = await aiCommunityMemberService.generateProactiveEngagement()
      
      if (engagement && engagement.content) {
        logger.info('âœ… Proactive engagement generated, creating question...')
        
        // Create a question from the proactive engagement
        const questionData = {
          title: this.extractQuestionTitle(engagement.content),
          content: engagement.content,
          tags: this.extractTags(engagement.content),
          author_id: engagement.authorId,
          is_ai_generated: true,
          metadata: {
            engagementType: 'proactive_question',
            persona: engagement.persona?.name || 'Unknown',
            confidence: engagement.confidence || 0.8
          }
        }
        
        logger.info('ğŸ“ Creating question with data:', JSON.stringify(questionData, null, 2))
        
        const question = await questionsService.createQuestion(questionData)
        
        if (question) {
          logger.info(\`âœ… Proactive question created with ID: \${question.id}\`)
          logger.info(\`ğŸ“ Question title: "\${question.title}"\`)
          logger.info(\`ğŸ‘¤ Generated by persona: \${engagement.persona?.name || 'Unknown'}\`)
          
          // Record this as a successful engagement
          this.stats.successfulEngagements++
          this.stats.totalEngagements++
          this.stats.lastEngagement = new Date()
          
          logger.info('ğŸ“Š Updated stats:', JSON.stringify(this.stats, null, 2))
        } else {
          logger.warn('âš ï¸ Failed to create proactive question')
          this.stats.failedEngagements++
          this.stats.totalEngagements++
        }
      } else {
        logger.warn('âš ï¸ No proactive engagement generated')
        this.stats.failedEngagements++
        this.stats.totalEngagements++
      }
      
    } catch (error) {
      logger.error('ğŸ’¥ Error generating proactive question:', error)
      logger.error('Stack trace:', error.stack)
      this.stats.failedEngagements++
      this.stats.totalEngagements++
      throw error
    }
  }

  // Extract a title from engagement content
  private extractQuestionTitle(content: string): string {
    // Try to extract the first sentence or first 50 characters
    const firstSentence = content.split('.')[0]
    if (firstSentence.length <= 50) {
      return firstSentence.trim()
    }
    
    // If first sentence is too long, take first 50 characters
    return content.substring(0, 50).trim() + '...'
  }

  // Extract relevant tags from content
  private extractTags(content: string): string[] {
    const tags = ['ai-generated', 'proactive']
    
    // Add tags based on content keywords
    const lowerContent = content.toLowerCase()
    
    if (lowerContent.includes('prototype') || lowerContent.includes('prototyping')) {
      tags.push('prototyping')
    }
    if (lowerContent.includes('design') || lowerContent.includes('ui') || lowerContent.includes('ux')) {
      tags.push('design')
    }
    if (lowerContent.includes('development') || lowerContent.includes('code') || lowerContent.includes('programming')) {
      tags.push('development')
    }
    if (lowerContent.includes('feedback') || lowerContent.includes('review')) {
      tags.push('feedback')
    }
    if (lowerContent.includes('collaboration') || lowerContent.includes('team')) {
      tags.push('collaboration')
    }
    
    return tags
  }

  `;
  
  content = beforeMethod + newMethod + afterMethod;
  
  // Write the updated content back
  fs.writeFileSync(filePath, content);
  console.log('âœ… Fixed forceEngagement method with better error handling and logging');
} else {
  console.log('âŒ Could not find forceEngagement method');
}
