// AI Community Member Monitoring Service
// Handles background monitoring, proactive engagement, and community analysis

import { aiCommunityMemberService } from "./aiCommunityMemberService.ts"
import { databaseService } from "./databaseService.ts"
import { logger } from "../utils/logger.ts"

export interface MonitoringConfig {
  proactiveEngagementInterval: number // minutes
  communityAnalysisInterval: number // minutes
  maxEngagementsPerHour: number
  engagementTypes: string[]
  activePersonas: string[]
}

export interface CommunityTrend {
  topic: string
  frequency: number
  sentiment: "positive" | "neutral" | "negative"
  trendingUp: boolean
  relatedQuestions: string[]
}

export interface EngagementOpportunity {
  type: "unanswered_question" | "trending_topic" | "collaboration_request" | "learning_opportunity"
  priority: "high" | "medium" | "low"
  targetId: string
  context: any
  suggestedPersona: string
  reason: string
}

export interface MonitoringStats {
  totalEngagements: number
  successfulEngagements: number
  failedEngagements: number
  activePersonas: number
  lastEngagement: Date
  communityHealth: number
  trendingTopics: CommunityTrend[]
}

// Default monitoring configuration
const DEFAULT_CONFIG: MonitoringConfig = {
  proactiveEngagementInterval: 30, // Every 30 minutes
  communityAnalysisInterval: 60, // Every hour
  maxEngagementsPerHour: 5,
  engagementTypes: ['question', 'prototype_share', 'learning_update', 'community_tip', 'collaboration_request'],
  activePersonas: ['proto-bot-alex', 'proto-bot-maya', 'proto-bot-jordan', 'proto-bot-sam']
}

class AIMonitoringService {
  private config: MonitoringConfig
  private isRunning: boolean = false
  private stats: MonitoringStats
  private engagementHistory: any[] = []
  private lastEngagementTime: Date = new Date(0)

  constructor(config: Partial<MonitoringConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config }
    this.stats = {
      totalEngagements: 0,
      successfulEngagements: 0,
      failedEngagements: 0,
      activePersonas: this.config.activePersonas.length,
      lastEngagement: new Date(0),
      communityHealth: 0,
      trendingTopics: []
    }
  }

  // Start the monitoring service
  async start(): Promise<void> {
    if (this.isRunning) {
      logger.warn('AI Monitoring Service is already running')
      return
    }

    this.isRunning = true
    logger.info('ü§ñ Starting AI Community Member Monitoring Service')

    // Start proactive engagement loop
    this.startProactiveEngagementLoop()
    
    // Start community analysis loop
    this.startCommunityAnalysisLoop()

    // Initial community analysis
    await this.analyzeCommunityTrends()

    logger.info('‚úÖ AI Monitoring Service started successfully')
  }

  // Stop the monitoring service
  async stop(): Promise<void> {
    this.isRunning = false
    logger.info('üõë AI Monitoring Service stopped')
  }

  // Proactive engagement loop
  private startProactiveEngagementLoop(): void {
    const intervalMs = this.config.proactiveEngagementInterval * 60 * 1000
    
    const runEngagement = async () => {
      if (!this.isRunning) return
      
      try {
        await this.processEngagementOpportunities()
      } catch (error) {
        logger.error('Error in proactive engagement loop:', error)
      }
      
      // Schedule next run
      setTimeout(runEngagement, intervalMs)
    }

    // Start first run after a short delay
    setTimeout(runEngagement, 5000)
  }

  // Community analysis loop
  private startCommunityAnalysisLoop(): void {
    const intervalMs = this.config.communityAnalysisInterval * 60 * 1000
    
    const runAnalysis = async () => {
      if (!this.isRunning) return
      
      try {
        await this.analyzeCommunityTrends()
        await this.updateCommunityHealth()
      } catch (error) {
        logger.error('Error in community analysis loop:', error)
      }
      
      // Schedule next run
      setTimeout(runAnalysis, intervalMs)
    }

    // Start first run after a short delay
    setTimeout(runAnalysis, 10000)
  }

  // Process engagement opportunities
  async processEngagementOpportunities(): Promise<void> {
    try {
      // Check if we're within engagement limits
      if (!this.canEngage()) {
        logger.info('‚è∏Ô∏è Engagement limit reached, skipping this cycle')
        return
      }

      // Find engagement opportunities
      const opportunities = await this.findEngagementOpportunities()
      
      if (opportunities.length === 0) {
        logger.info('üîç No engagement opportunities found')
        return
      }

      // Process highest priority opportunity
      const opportunity = opportunities[0]
      logger.info(`üéØ Processing engagement opportunity: ${opportunity.type} (${opportunity.priority})`)

      await this.executeEngagement(opportunity)
      
    } catch (error) {
      logger.error('Error processing engagement opportunities:', error)
    }
  }

  // Find engagement opportunities
  async findEngagementOpportunities(): Promise<EngagementOpportunity[]> {
    const opportunities: EngagementOpportunity[] = []

    try {
      // 1. Find unanswered questions
      const unansweredQuestions = await this.findUnansweredQuestions()
      opportunities.push(...unansweredQuestions)

      // 2. Find trending topics that need engagement
      const trendingOpportunities = await this.findTrendingOpportunities()
      opportunities.push(...trendingOpportunities)

      // 3. Find collaboration opportunities
      const collaborationOpportunities = await this.findCollaborationOpportunities()
      opportunities.push(...collaborationOpportunities)

      // 4. Find learning opportunities
      const learningOpportunities = await this.findLearningOpportunities()
      opportunities.push(...learningOpportunities)

      // Sort by priority
      return opportunities.sort((a, b) => {
        const priorityOrder = { high: 3, medium: 2, low: 1 }
        return priorityOrder[b.priority] - priorityOrder[a.priority]
      })

    } catch (error) {
      logger.error('Error finding engagement opportunities:', error)
      return []
    }
  }

  // Find unanswered questions
  private async findUnansweredQuestions(): Promise<EngagementOpportunity[]> {
    try {
      const questions = await databaseService.getQuestions({ 
        sortBy: 'unanswered',
        limit: 10 
      })

      return questions
        .filter(q => (!q.answers_count || q.answers_count === 0) && !q.is_ai_generated)
        .slice(0, 3) // Limit to 3 opportunities
        .map(question => ({
          type: 'unanswered_question' as const,
          priority: this.calculateQuestionPriority(question),
          targetId: question.id,
          context: question,
          suggestedPersona: this.selectPersonaForQuestion(question),
          reason: `Unanswered question: "${question.title}"`
        }))

    } catch (error) {
      logger.error('Error finding unanswered questions:', error)
      return []
    }
  }

  // Find trending opportunities
  private async findTrendingOpportunities(): Promise<EngagementOpportunity[]> {
    try {
      const trendingTopics = this.stats.trendingTopics
      
      return trendingTopics
        .filter(topic => topic.trendingUp && topic.frequency > 3)
        .slice(0, 2)
        .map(topic => ({
          type: 'trending_topic' as const,
          priority: 'medium' as const,
          targetId: topic.topic,
          context: topic,
          suggestedPersona: this.selectPersonaForTopic(topic.topic),
          reason: `Trending topic: "${topic.topic}"`
        }))

    } catch (error) {
      logger.error('Error finding trending opportunities:', error)
      return []
    }
  }

  // Find collaboration opportunities
  private async findCollaborationOpportunities(): Promise<EngagementOpportunity[]> {
    try {
      // Look for questions with collaboration-related tags
      const questions = await databaseService.getQuestions({ 
        tag: 'collaboration',
        limit: 5 
      })

      return questions
        .filter(q => q.answers_count < 2) // Not too many answers yet
        .slice(0, 2)
        .map(question => ({
          type: 'collaboration_request' as const,
          priority: 'medium' as const,
          targetId: question.id,
          context: question,
          suggestedPersona: this.selectPersonaForQuestion(question),
          reason: `Collaboration opportunity: "${question.title}"`
        }))

    } catch (error) {
      logger.error('Error finding collaboration opportunities:', error)
      return []
    }
  }

  // Find learning opportunities
  private async findLearningOpportunities(): Promise<EngagementOpportunity[]> {
    try {
      // Look for beginner questions or learning-related content
      const questions = await databaseService.getQuestions({ 
        tag: 'learning',
        limit: 5 
      })

      return questions
        .filter(q => q.answers_count < 3)
        .slice(0, 2)
        .map(question => ({
          type: 'learning_opportunity' as const,
          priority: 'high' as const,
          targetId: question.id,
          context: question,
          suggestedPersona: this.selectPersonaForQuestion(question),
          reason: `Learning opportunity: "${question.title}"`
        }))

    } catch (error) {
      logger.error('Error finding learning opportunities:', error)
      return []
    }
  }

  // Execute engagement opportunity
  async executeEngagement(opportunity: EngagementOpportunity): Promise<void> {
    try {
      let engagement: any = null

      switch (opportunity.type) {
        case 'unanswered_question':
          engagement = await this.engageWithQuestion(opportunity)
          break
        case 'trending_topic':
          engagement = await this.engageWithTrendingTopic(opportunity)
          break
        case 'collaboration_request':
          engagement = await this.engageWithCollaboration(opportunity)
          break
        case 'learning_opportunity':
          engagement = await this.engageWithLearning(opportunity)
          break
      }

      if (engagement) {
        await this.recordEngagement(opportunity, engagement)
        this.stats.successfulEngagements++
        this.stats.lastEngagement = new Date()
        logger.info(`‚úÖ Successfully executed ${opportunity.type} engagement`)
      }

    } catch (error) {
      logger.error(`Error executing engagement ${opportunity.type}:`, error)
      this.stats.failedEngagements++
    }
  }

  // Engage with unanswered question
  private async engageWithQuestion(opportunity: EngagementOpportunity): Promise<any> {
    const question = opportunity.context
    
    // Create context for AI response
    const context = {
      questionId: question.id,
      questionContent: question.content,
      questionAuthor: question.author_id,
      previousResponses: [],
      communityTrends: this.stats.trendingTopics.map(t => t.topic),
      userInterests: [],
      conversationHistory: []
    }

    const aiResponse = await aiCommunityMemberService.generateResponse(question, context)
    
    if (aiResponse) {
      // Create answer in database
      await databaseService.createAnswer({
        question_id: question.id,
        content: aiResponse.content,
        author_id: aiResponse.authorId,
        is_ai: true,
        metadata: {
          persona: aiResponse.persona?.name,
          confidence: aiResponse.confidence,
          emotionalTone: aiResponse.emotionalTone,
          followUpQuestions: aiResponse.followUpQuestions,
          engagementType: 'unanswered_question'
        }
      })

      return aiResponse
    }

    return null
  }

  // Engage with trending topic
  private async engageWithTrendingTopic(opportunity: EngagementOpportunity): Promise<any> {
    const topic = opportunity.context.topic
    
    // Generate proactive engagement about the trending topic
    const engagement = await aiCommunityMemberService.generateProactiveEngagement()
    
    if (engagement) {
      // Create a question about the trending topic
      const question = await databaseService.createQuestion({
        title: `Discussion: ${topic}`,
        content: engagement.content,
        tags: [topic, 'trending', 'discussion'],
        author_id: engagement.authorId,
        is_ai_generated: true,
        metadata: {
          engagementType: 'trending_topic',
          originalTopic: topic
        }
      })

      return { question, engagement }
    }

    return null
  }

  // Engage with collaboration request
  private async engageWithCollaboration(opportunity: EngagementOpportunity): Promise<any> {
    const question = opportunity.context
    
    // Generate collaboration-focused response
    const context = {
      questionId: question.id,
      questionContent: question.content,
      questionAuthor: question.author_id,
      previousResponses: [],
      communityTrends: [],
      userInterests: [],
      conversationHistory: []
    }

    const aiResponse = await aiCommunityMemberService.generateResponse(question, context)
    
    if (aiResponse) {
      await databaseService.createAnswer({
        question_id: question.id,
        content: aiResponse.content,
        author_id: aiResponse.authorId,
        is_ai: true,
        metadata: {
          persona: aiResponse.persona?.name,
          confidence: aiResponse.confidence,
          emotionalTone: aiResponse.emotionalTone,
          followUpQuestions: aiResponse.followUpQuestions,
          engagementType: 'collaboration_request'
        }
      })

      return aiResponse
    }

    return null
  }

  // Engage with learning opportunity
  private async engageWithLearning(opportunity: EngagementOpportunity): Promise<any> {
    const question = opportunity.context
    
    // Generate learning-focused response
    const context = {
      questionId: question.id,
      questionContent: question.content,
      questionAuthor: question.author_id,
      previousResponses: [],
      communityTrends: [],
      userInterests: [],
      conversationHistory: []
    }

    const aiResponse = await aiCommunityMemberService.generateResponse(question, context)
    
    if (aiResponse) {
      await databaseService.createAnswer({
        question_id: question.id,
        content: aiResponse.content,
        author_id: aiResponse.authorId,
        is_ai: true,
        metadata: {
          persona: aiResponse.persona?.name,
          confidence: aiResponse.confidence,
          emotionalTone: aiResponse.emotionalTone,
          followUpQuestions: aiResponse.followUpQuestions,
          engagementType: 'learning_opportunity'
        }
      })

      return aiResponse
    }

    return null
  }

  // Analyze community trends
  async analyzeCommunityTrends(): Promise<void> {
    try {
      logger.info('üìä Analyzing community trends...')
      
      // Get recent questions and answers
      const questions = await databaseService.getQuestions({ 
        sortBy: 'newest',
        limit: 50 
      })

      // Analyze topics and trends
      const topicFrequency: Record<string, number> = {}
      const topicSentiment: Record<string, number> = {}

      questions.forEach(question => {
        if (question.tags) {
          question.tags.forEach(tag => {
            topicFrequency[tag] = (topicFrequency[tag] || 0) + 1
            // Simple sentiment analysis based on question content
            const sentiment = this.analyzeSentiment(question.content)
            topicSentiment[tag] = (topicSentiment[tag] || 0) + sentiment
          })
        }
      })

      // Convert to trending topics
      this.stats.trendingTopics = Object.entries(topicFrequency)
        .map(([topic, frequency]) => ({
          topic,
          frequency,
          sentiment: topicSentiment[topic] > 0 ? 'positive' : topicSentiment[topic] < 0 ? 'negative' : 'neutral',
          trendingUp: frequency > 2,
          relatedQuestions: questions.filter(q => q.tags?.includes(topic)).map(q => q.id)
        }))
        .sort((a, b) => b.frequency - a.frequency)
        .slice(0, 10)

      logger.info(`üìà Found ${this.stats.trendingTopics.length} trending topics`)

    } catch (error) {
      logger.error('Error analyzing community trends:', error)
    }
  }

  // Update community health score
  async updateCommunityHealth(): Promise<void> {
    try {
      // Calculate community health based on various metrics
      const questions = await databaseService.getQuestions({ limit: 100 })
      const totalQuestions = questions.length
      const answeredQuestions = questions.filter(q => q.answers_count > 0).length
      const recentActivity = questions.filter(q => {
        const questionDate = new Date(q.created_at)
        const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000)
        return questionDate > oneDayAgo
      }).length

      // Calculate health score (0-100)
      const answerRate = totalQuestions > 0 ? (answeredQuestions / totalQuestions) * 100 : 0
      const activityScore = Math.min(recentActivity * 2, 50) // Max 50 points for activity
      const trendScore = Math.min(this.stats.trendingTopics.length * 5, 30) // Max 30 points for trends

      this.stats.communityHealth = Math.round(answerRate * 0.4 + activityScore + trendScore)

      logger.info(`üíö Community health: ${this.stats.communityHealth}/100`)

    } catch (error) {
      logger.error('Error updating community health:', error)
    }
  }

  // Helper methods
  private canEngage(): boolean {
    const now = new Date()
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000)
    
    const recentEngagements = this.engagementHistory.filter(
      e => new Date(e.timestamp) > oneHourAgo
    )

    return recentEngagements.length < this.config.maxEngagementsPerHour
  }

  private calculateQuestionPriority(question: any): 'high' | 'medium' | 'low' {
    const age = Date.now() - new Date(question.created_at).getTime()
    const ageInHours = age / (1000 * 60 * 60)
    
    if (ageInHours > 24) return 'high' // Old unanswered questions
    if (ageInHours > 6) return 'medium'
    return 'low'
  }

  private selectPersonaForQuestion(question: any): string {
    // Simple persona selection based on question tags
    const tags = question.tags || []
    
    if (tags.some(tag => ['design', 'ui', 'ux'].includes(tag.toLowerCase()))) {
      return 'proto-bot-maya'
    } else if (tags.some(tag => ['coding', 'development', 'technical'].includes(tag.toLowerCase()))) {
      return 'proto-bot-jordan'
    } else if (tags.some(tag => ['product', 'business', 'strategy'].includes(tag.toLowerCase()))) {
      return 'proto-bot-sam'
    } else {
      return 'proto-bot-alex' // Default to Alex
    }
  }

  private selectPersonaForTopic(topic: string): string {
    const topicLower = topic.toLowerCase()
    
    if (['design', 'ui', 'ux', 'figma'].some(t => topicLower.includes(t))) {
      return 'proto-bot-maya'
    } else if (['coding', 'development', 'javascript', 'react'].some(t => topicLower.includes(t))) {
      return 'proto-bot-jordan'
    } else if (['product', 'business', 'strategy', 'analytics'].some(t => topicLower.includes(t))) {
      return 'proto-bot-sam'
    } else {
      return 'proto-bot-alex'
    }
  }

  private analyzeSentiment(text: string): number {
    const positiveWords = ['great', 'awesome', 'excellent', 'love', 'amazing', 'fantastic']
    const negativeWords = ['problem', 'issue', 'difficult', 'struggle', 'challenge', 'error']
    
    const lowerText = text.toLowerCase()
    let sentiment = 0
    
    positiveWords.forEach(word => {
      if (lowerText.includes(word)) sentiment++
    })
    
    negativeWords.forEach(word => {
      if (lowerText.includes(word)) sentiment--
    })
    
    return sentiment
  }

  private async recordEngagement(opportunity: EngagementOpportunity, engagement: any): Promise<void> {
    const record = {
      timestamp: new Date().toISOString(),
      type: opportunity.type,
      priority: opportunity.priority,
      targetId: opportunity.targetId,
      persona: engagement.persona?.name || 'unknown',
      success: true
    }

    this.engagementHistory.push(record)
    this.stats.totalEngagements++

    // Keep only last 100 engagements
    if (this.engagementHistory.length > 100) {
      this.engagementHistory = this.engagementHistory.slice(-100)
    }
  }

  // Public methods for monitoring and control
  getStats(): MonitoringStats {
    return { ...this.stats }
  }

  getConfig(): MonitoringConfig {
    return { ...this.config }
  }

  updateConfig(newConfig: Partial<MonitoringConfig>): void {
    this.config = { ...this.config, ...newConfig }
    logger.info('üìù Monitoring configuration updated')
  }

  getEngagementHistory(): any[] {
    return [...this.engagementHistory]
  }

  async forceEngagement(): Promise<void> {
    logger.info('üöÄ Forcing immediate engagement...')
    await this.processEngagementOpportunities()
  }

  async forceAnalysis(): Promise<void> {
    logger.info('ÔøΩÔøΩ Forcing immediate community analysis...')
    await this.analyzeCommunityTrends()
    await this.updateCommunityHealth()
  }
}

// Export singleton instance
export const aiMonitoringService = new AIMonitoringService()

// Export the class for testing
export { AIMonitoringService }
