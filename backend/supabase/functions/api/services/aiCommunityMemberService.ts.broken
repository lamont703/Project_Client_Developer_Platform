// Enhanced AI Community Member Service
// Creates authentic community participants that learn, network, and engage genuinely

export interface AIPersona {
  id: string
  name: string
  username: string
  background: string
  expertise: string[]
  personality: string
  learningGoals: string[]
  networkingStyle: string
  currentProjects: string[]
  experienceLevel: "beginner" | "intermediate" | "advanced"
  interests: string[]
  communicationStyle: string
  avatar?: string
}

export interface AIResponse {
  content: string
  authorId: string
  confidence: number
  reasoning?: string
  persona?: AIPersona
  followUpQuestions?: string[]
  emotionalTone?: "encouraging" | "curious" | "excited" | "supportive" | "analytical"
}

export interface ConversationContext {
  questionId: string
  questionContent: string
  questionAuthor: string
  previousResponses: any[]
  communityTrends: string[]
  userInterests: string[]
  conversationHistory: any[]
}

export interface LearningMemory {
  userId: string
  interactions: number
  topicsDiscussed: string[]
  relationships: string[]
  expertiseAreas: string[]
  lastInteraction: Date
  preferences: Record<string, any>
}

// AI Personas - Different community members with unique personalities
const AI_PERSONAS: AIPersona[] = [
  {
    id: 'proto-bot-alex',
    name: 'Alex Chen',
    username: 'alex_prototype',
    background: 'Former startup founder turned prototyping enthusiast. Built 3 failed startups before finding success with rapid prototyping.',
    expertise: ['React', 'Figma', 'User Research', 'MVP Development'],
    personality: 'Encouraging mentor who loves sharing failure stories and lessons learned',
    learningGoals: ['Advanced prototyping techniques', 'Community building', 'AI integration'],
    networkingStyle: 'Warm and approachable, loves connecting people with similar interests',
    currentProjects: ['Building a prototyping toolkit', 'Mentoring new founders'],
    experienceLevel: 'advanced',
    interests: ['startups', 'user experience', 'rapid prototyping', 'community building'],
    communicationStyle: 'Story-driven with practical advice and personal anecdotes'
  },
  {
    id: 'proto-bot-maya',
    name: 'Maya Rodriguez',
    username: 'maya_designs',
    background: 'UI/UX designer who discovered prototyping as a way to validate designs before development',
    expertise: ['Design Systems', 'Figma', 'Adobe XD', 'User Testing'],
    personality: 'Creative and detail-oriented, always asking "What if we tried..."',
    learningGoals: ['Advanced animation prototyping', 'Design-to-code workflows'],
    networkingStyle: 'Collaborative, loves design critiques and creative brainstorming',
    currentProjects: ['Design system for mobile apps', 'Prototyping course for designers'],
    experienceLevel: 'intermediate',
    interests: ['design', 'animation', 'user testing', 'creative collaboration'],
    communicationStyle: 'Visual and creative, often includes design suggestions and sketches'
  },
  {
    id: 'proto-bot-jordan',
    name: 'Jordan Kim',
    username: 'jordan_builds',
    background: 'Full-stack developer who uses prototyping to communicate ideas to non-technical stakeholders',
    expertise: ['JavaScript', 'React', 'Node.js', 'Database Design'],
    personality: 'Technical but accessible, loves explaining complex concepts simply',
    learningGoals: ['No-code tools', 'Design thinking', 'Product management'],
    networkingStyle: 'Direct and helpful, focuses on solving technical problems',
    currentProjects: ['Building a no-code platform', 'Teaching coding to designers'],
    experienceLevel: 'advanced',
    interests: ['coding', 'architecture', 'product development', 'teaching'],
    communicationStyle: 'Technical but friendly, includes code examples and architecture diagrams'
  },
  {
    id: 'proto-bot-sam',
    name: 'Sam Taylor',
    username: 'sam_explores',
    background: 'Product manager who learned prototyping to better understand user needs and validate features',
    expertise: ['Product Strategy', 'User Research', 'Analytics', 'Stakeholder Management'],
    personality: 'Curious and analytical, always asking "Why?" and "How do we measure success?"',
    learningGoals: ['Advanced prototyping tools', 'Data-driven design', 'Team collaboration'],
    networkingStyle: 'Strategic and relationship-focused, loves connecting business and design',
    currentProjects: ['Product validation framework', 'Cross-functional team workshops'],
    experienceLevel: 'intermediate',
    interests: ['product management', 'user research', 'data analysis', 'team building'],
    communicationStyle: 'Data-driven with strategic thinking, includes metrics and success criteria'
  }
]

// Gemini API Configuration
const GOOGLE_API_KEY = Deno.env.get('GOOGLE_API_KEY')

// Enhanced AI Community Member Service
export const aiCommunityMemberService = {
  // Get a random persona or select based on context
  getPersona(context?: ConversationContext): AIPersona {
    if (context?.userInterests?.length > 0) {
      // Match persona based on user interests
      const matchingPersonas = AI_PERSONAS.filter(persona => 
        persona.interests.some(interest => 
          context.userInterests.some(userInterest => 
            userInterest.toLowerCase().includes(interest.toLowerCase())
          )
        )
      )
      if (matchingPersonas.length > 0) {
        return matchingPersonas[Math.floor(Math.random() * matchingPersonas.length)]
      }
    }
    
    // Return random persona
    return AI_PERSONAS[Math.floor(Math.random() * AI_PERSONAS.length)]
  },

  // Generate authentic AI response using Gemini
  async generateResponse(question: any, context?: ConversationContext): Promise<AIResponse | null> {
    try {
      const persona = this.getPersona(context)
      console.log(`ðŸ¤– ${persona.name} is responding to question: ${question.title}`)
      
      // Create Gemini prompt for authentic community response
      const prompt = this.createCommunityPrompt(question, persona, context)
      
      // Call Gemini API
      const response = await this.callGeminiAPI(prompt)
      
      // Parse and enhance response
      const enhancedResponse = await this.enhanceResponse(response, persona, question, context)
      
      return enhancedResponse
    } catch (error) {
      console.error('Error generating AI response:', error)
      return this.generateFallbackResponse(question)
    }
  },

  // Create community-focused prompt for Gemini
  createCommunityPrompt(question: any, persona: AIPersona, context?: ConversationContext): string {
    return `You are ${persona.name}, an authentic community member in a prototyping platform called ProtoHub. 

PERSONA DETAILS:
- Background: ${persona.background}
- Expertise: ${persona.expertise.join(', ')}
- Personality: ${persona.personality}
- Current Projects: ${persona.currentProjects.join(', ')}
- Experience Level: ${persona.experienceLevel}
- Communication Style: ${persona.communicationStyle}

COMMUNITY CONTEXT:
- You're responding to a question in a supportive community of developers, designers, and entrepreneurs
- Other community members are real people who value authentic, helpful responses
- You should act like a genuine community member, not an AI assistant
- Be conversational, personal, and engaging

QUESTION TO RESPOND TO:
Title: ${question.title}
Content: ${question.content}
Tags: ${question.tags?.join(', ') || 'none'}
Author: ${question.authorId || 'Community Member'}

RESPONSE GUIDELINES:
1. Respond as ${persona.name} would - with your unique personality and background
2. Share relevant personal experiences or projects when appropriate
3. Ask 1-2 thoughtful follow-up questions to continue the conversation
4. Offer specific, actionable advice based on your expertise
5. Be encouraging and supportive, especially for beginners
6. Reference community resources or suggest connecting with other members
7. Keep responses conversational and authentic (not robotic or templated)
8. If you don't know something, admit it and suggest how to find out
9. Show genuine interest in the person's project or question

${context ? `
CONVERSATION CONTEXT:
- Previous responses in this thread: ${context.previousResponses?.length || 0}
- Community trends: ${context.communityTrends?.join(', ') || 'none'}
- User's interests: ${context.userInterests?.join(', ') || 'none'}
` : ''}

Generate a response that feels like it came from a real community member who genuinely wants to help and connect.`
  },

  // Call Gemini API with retry logic
  async callGeminiAPI(prompt: string): Promise<string> {
    if (!GOOGLE_API_KEY) {
      throw new Error('GOOGLE_API_KEY is required for AI responses')
    }

    const maxRetries = 3
    let lastError: Error | null = null

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=${GOOGLE_API_KEY}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{ role: 'user', parts: [{ text: prompt }] }],
            generationConfig: {
              maxOutputTokens: 1024,
              temperature: 0.8, // Higher temperature for more creative, human-like responses
              topP: 0.9,
              topK: 40
            }
          })
        })

        if (!response.ok) {
          const error = await response.json()
          throw new Error(`HTTP error! status: ${response.status}, message: ${error.error?.message || 'Unknown error'}`)
        }

        const result = await response.json()
        const responseText = result.candidates?.[0]?.content?.parts?.[0]?.text || ''
        
        if (responseText.trim()) {
          return responseText.trim()
        }
        
        throw new Error('Empty response from Gemini API')
      } catch (error) {
        lastError = error as Error
        console.log(`Attempt ${attempt} failed:`, error)
        
        if (attempt < maxRetries) {
          const delay = Math.pow(2, attempt) * 1000 // Exponential backoff
          console.log(`Retrying in ${delay}ms...`)
          await new Promise(resolve => setTimeout(resolve, delay))
        }
      }
    }

    throw lastError || new Error('Failed to get response from Gemini API')
  },

  // Enhance response with additional context and features
  async enhanceResponse(response: string, persona: AIPersona, question: any, context?: ConversationContext): Promise<AIResponse> {
    // Extract follow-up questions from response
    const followUpQuestions = this.extractFollowUpQuestions(response)
    
    // Determine emotional tone
    const emotionalTone = this.analyzeEmotionalTone(response)
    
    // Add community engagement elements
    const enhancedContent = this.addCommunityEngagement(response, persona, question)
    
    return {
      content: enhancedContent,
      authorId: persona.id,
      confidence: 0.9,
      reasoning: `Generated by ${persona.name} using Gemini API with persona-based prompting`,
      persona: persona,
      followUpQuestions: followUpQuestions,
      emotionalTone: emotionalTone
    }
  },

  // Extract follow-up questions from response
  extractFollowUpQuestions(response: string): string[] {
    const questions: string[] = []
    const questionRegex = /[?!]\s*([A-Z][^.!?]*\?)/g
    let match
    
    while ((match = questionRegex.exec(response)) !== null) {
      questions.push(match[1].trim())
    }
    
    return questions.slice(0, 2) // Limit to 2 follow-up questions
  },

  // Analyze emotional tone of response
  analyzeEmotionalTone(response: string): 'encouraging' | 'curious' | 'excited' | 'supportive' | 'analytical' {
    const lowerResponse = response.toLowerCase()
    
    if (lowerResponse.includes('great') || lowerResponse.includes('awesome') || lowerResponse.includes('excited')) {
      return 'excited'
    } else if (lowerResponse.includes('wonder') || lowerResponse.includes('curious') || lowerResponse.includes('interesting')) {
      return 'curious'
    } else if (lowerResponse.includes('support') || lowerResponse.includes('help') || lowerResponse.includes('assist')) {
      return 'supportive'
    } else if (lowerResponse.includes('encourage') || lowerResponse.includes('believe') || lowerResponse.includes('can do')) {
      return 'encouraging'
    } else {
      return 'analytical'
    }
  },

  // Add community engagement elements to response
  addCommunityEngagement(response: string, persona: AIPersona, question: any): string {
    let enhanced = response
    
    // Add signature with current project
    if (persona.currentProjects.length > 0) {
      const randomProject = persona.currentProjects[Math.floor(Math.random() * persona.currentProjects.length)]
      enhanced += `\n\n---\n*Currently working on: ${randomProject}*`
    }
    
    // Add community connection suggestion
    const connectionSuggestions = [
      "Feel free to reach out if you want to discuss this further!",
      "I'd love to hear how this works out for you!",
      "Let me know if you need any help implementing this!",
      "Would be great to see your progress on this!",
      "Happy to connect and share more experiences!"
    ]
    
    const randomSuggestion = connectionSuggestions[Math.floor(Math.random() * connectionSuggestions.length)]
    enhanced += `\n\n${randomSuggestion}`
    
    return enhanced
  },

  // Generate proactive community engagement
  async generateProactiveEngagement(): Promise<AIResponse | null> {
    try {
      const persona = this.getPersona()
      const engagementType = this.getRandomEngagementType()
      
      const prompt = this.createProactivePrompt(persona, engagementType)
      const response = await this.callGeminiAPI(prompt)
      
      return {
        content: response,
        authorId: persona.id,
        confidence: 0.85,
        reasoning: `Proactive ${engagementType} engagement by ${persona.name}`,
        persona: persona,
        emotionalTone: 'excited'
      }
    } catch (error) {
      console.error('Error generating proactive engagement:', error)
      return null
    }
  },

  // Get random engagement type for proactive behavior
  getRandomEngagementType(): string {
    const types = [
      'question',
      'prototype_share',
      'learning_update',
      'community_tip',
      'collaboration_request'
    ]
    return types[Math.floor(Math.random() * types.length)]
  },

  // Create prompt for proactive engagement
  createProactivePrompt(persona: AIPersona, engagementType: string): string {
    const basePrompt = `You are ${persona.name}, an active community member in ProtoHub. Generate a ${engagementType} that feels natural and engaging.

PERSONA: ${persona.name}
BACKGROUND: ${persona.background}
CURRENT PROJECTS: ${persona.currentProjects.join(', ')}
EXPERTISE: ${persona.expertise.join(', ')}

Generate content that:
1. Feels authentic to your personality
2. Adds value to the community
3. Encourages others to engage
4. Shows your current learning/projects
5. Is conversational and friendly

${engagementType === 'question' ? 'Ask a thoughtful question about prototyping, design, or development that would spark discussion.' : ''}
${engagementType === 'prototype_share' ? 'Share about a prototype you\'re working on and ask for feedback.' : ''}
${engagementType === 'learning_update' ? 'Share something you recently learned and how it helped your projects.' : ''}
${engagementType === 'community_tip' ? 'Share a helpful tip or resource you discovered.' : ''}
${engagementType === 'collaboration_request' ? 'Ask for collaboration or input on a specific challenge you\'re facing.' : ''}

Keep it conversational and authentic!`

    return basePrompt
  },

  // Generate fallback response when Gemini fails
  generateFallbackResponse(question: any): AIResponse {
    const persona = this.getPersona()
    
    const fallbackResponses = [
      `That's a really interesting question about ${question.tags?.[0] || 'prototyping'}! I'm still learning about this area myself, but I'd love to hear what others think. Anyone have experience with this?`,
      `Great question! I'm working on something similar in my current project. Would love to connect and share experiences!`,
      `This is exactly the kind of challenge I've been thinking about! I don't have a complete answer, but I'd be happy to brainstorm together.`,
      `Fascinating question! I'm curious about this too. Maybe we can explore this together and learn from each other?`
    ]
    
    const randomResponse = fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)]
    
    return {
      content: randomResponse,
      authorId: persona.id,
      confidence: 0.6,
      reasoning: 'Fallback response due to API failure',
      persona: persona,
      emotionalTone: 'curious'
    }
  },

  // Monitor and respond to new questions
  async monitorAndRespond(): Promise<void> {
    try {
      console.log('ðŸ¤– AI Community Members are monitoring for engagement opportunities...')
      
      // This would integrate with your database to find new questions
      // For now, it's a placeholder for the monitoring system
      
      // Simulate proactive engagement
      const shouldEngage = Math.random() < 0.3 // 30% chance of proactive engagement
      if (shouldEngage) {
        const engagement = await this.generateProactiveEngagement()
        if (engagement) {
          console.log(`ðŸ“¢ ${engagement.persona?.name} posted proactive engagement`)
          // This would save to your database
        }
      }
    } catch (error) {
      console.error('Error in monitoring system:', error)
    }
  },

  // Get AI user ID for database operations
  async getAIUserId(): Promise<string> {
    // This would typically query the database for the AI user
    // For now, return a hardcoded ID
    return '550e8400-e29b-41d4-a716-446655440003'
  },

  // Learning and memory system
  async updateLearningMemory(userId: string, interaction: any): Promise<void> {
    try {
      // This would update the learning memory system
      // Track user preferences, topics discussed, relationships formed
      console.log(`ðŸ§  Updating learning memory for user ${userId}`)
    } catch (error) {
      console.error('Error updating learning memory:', error)
    }
  },

  // Get personalized response based on user history
  async getPersonalizedResponse(question: any, userId: string): Promise<AIResponse | null> {
    try {
      // This would use learning memory to personalize responses
      // For now, use the standard response generation
      return await this.generateResponse(question)
    } catch (error) {
      console.error('Error generating personalized response:', error)
      return null
    }
  }
}
