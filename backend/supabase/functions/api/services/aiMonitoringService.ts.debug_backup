// AI Community Member Monitoring Service
// Handles background monitoring, proactive engagement, and community analysis

import { aiCommunityMemberService } from "./aiCommunityMemberService.ts"
import { databaseService } from "./databaseService.ts"
import { logger } from "../utils/logger.ts"

export interface MonitoringConfig {
  proactiveEngagementInterval: number // minutes
  communityAnalysisInterval: number // minutes
  maxEngagementsPerHour: number
  engagementTypes: string[]
  activePersonas: string[]
}

export interface CommunityTrend {
  topic: string
  frequency: number
  sentiment: "positive" | "neutral" | "negative"
  trendingUp: boolean
  relatedQuestions: string[]
}

export interface EngagementOpportunity {
  type: "unanswered_question" | "trending_topic" | "collaboration_request" | "learning_opportunity"
  priority: "high" | "medium" | "low"
  targetId: string
  context: any
  suggestedPersona: string
  reason: string
}

export interface MonitoringStats {
  totalEngagements: number
  successfulEngagements: number
  failedEngagements: number
  activePersonas: number
  lastEngagement: Date
  communityHealth: number
  trendingTopics: CommunityTrend[]
}

// Default monitoring configuration
const DEFAULT_CONFIG: MonitoringConfig = {
  proactiveEngagementInterval: 30, // Every 30 minutes
  communityAnalysisInterval: 60, // Every hour
  maxEngagementsPerHour: 5,
  engagementTypes: ['question', 'prototype_share', 'learning_update', 'community_tip', 'collaboration_request'],
  activePersonas: ['proto-bot-alex', 'proto-bot-maya', 'proto-bot-jordan', 'proto-bot-sam']
}

class AIMonitoringService {
  private config: MonitoringConfig
  private isRunning: boolean = false
  private stats: MonitoringStats
  private engagementHistory: any[] = []
  private lastEngagementTime: Date = new Date(0)

  constructor(config: Partial<MonitoringConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config }
    this.stats = {
      totalEngagements: 0,
      successfulEngagements: 0,
      failedEngagements: 0,
      activePersonas: this.config.activePersonas.length,
      lastEngagement: new Date(0),
      communityHealth: 0,
      trendingTopics: []
    }
  }

  // Start the monitoring service
  async start(): Promise<void> {
    if (this.isRunning) {
      logger.warn('AI Monitoring Service is already running')
      return
    }

    this.isRunning = true
    logger.info('ü§ñ Starting AI Community Member Monitoring Service')

    // Start proactive engagement loop
    this.startProactiveEngagementLoop()
    
    // Start community analysis loop
    this.startCommunityAnalysisLoop()

    // Initial community analysis
    await this.analyzeCommunityTrends()

    logger.info('‚úÖ AI Monitoring Service started successfully')
  }

  // Stop the monitoring service
  async stop(): Promise<void> {
    this.isRunning = false
    logger.info('üõë AI Monitoring Service stopped')
  }

  // Proactive engagement loop
  private startProactiveEngagementLoop(): void {
    const intervalMs = this.config.proactiveEngagementInterval * 60 * 1000
    logger.info(`üîÑ Starting proactive engagement loop with ${this.config.proactiveEngagementInterval}min interval`)
    
    const runEngagement = async () => {
      if (!this.isRunning) {
        logger.info('üõë Monitoring service stopped, ending engagement loop')
        return
      }
      
      try {
        logger.info('üéØ Running proactive engagement cycle...')
        await this.processEngagementOpportunities()
      } catch (error) {
        logger.error('üí• Error in proactive engagement loop:', error)
      }
      
      // Schedule next run
      logger.info(`‚è∞ Next engagement cycle in ${this.config.proactiveEngagementInterval} minutes`)
      setTimeout(runEngagement, intervalMs)
    }

    // Start first run after a short delay
    setTimeout(runEngagement, 5000)
  }

  // Community analysis loop
  private startCommunityAnalysisLoop(): void {
    const intervalMs = this.config.communityAnalysisInterval * 60 * 1000
    logger.info(`üìä Starting community analysis loop with ${this.config.communityAnalysisInterval}min interval`)
    
    const runAnalysis = async () => {
      if (!this.isRunning) {
        logger.info('üõë Monitoring service stopped, ending analysis loop')
        return
      }
      
      try {
        logger.info('üìà Running community analysis cycle...')
        await this.analyzeCommunityTrends()
        await this.updateCommunityHealth()
      } catch (error) {
        logger.error('üí• Error in community analysis loop:', error)
      }
      
      // Schedule next run
      logger.info(`‚è∞ Next analysis cycle in ${this.config.communityAnalysisInterval} minutes`)
      setTimeout(runAnalysis, intervalMs)
    }

    // Start first run after a short delay
    setTimeout(runAnalysis, 10000)
  }

  // Process engagement opportunities
  async processEngagementOpportunities(): Promise<void> {
    try {
      logger.info('üîç Processing engagement opportunities...')

      // Check if we're within engagement limits
      const canEngage = this.canEngage()
      logger.info(`üìä Engagement check: canEngage=${canEngage}, recent engagements: ${this.getRecentEngagementsCount()}/${this.config.maxEngagementsPerHour}`)
      
      if (!canEngage) {
        logger.info('‚è∏Ô∏è Engagement limit reached, skipping this cycle')
        return
      }

      // Find engagement opportunities
      logger.info('üîç Finding engagement opportunities...')
      const opportunities = await this.findEngagementOpportunities()
      
      logger.info(`üìã Found ${opportunities.length} engagement opportunities:`)
      opportunities.forEach((opp, index) => {
        logger.info(`  ${index + 1}. ${opp.type} (${opp.priority}) - ${opp.reason}`)
      })
      
      if (opportunities.length === 0) {
        logger.info('üîç No engagement opportunities found')
        return
      }

      // Process highest priority opportunity
      const opportunity = opportunities[0]
      logger.info(`üéØ Processing highest priority opportunity: ${opportunity.type} (${opportunity.priority})`)
      logger.info(`üìù Context: ${JSON.stringify(opportunity.context, null, 2)}`)

      await this.executeEngagement(opportunity)
      
    } catch (error) {
      logger.error('üí• Error processing engagement opportunities:', error)
      logger.error('Stack trace:', error.stack)
    }
  }

  // Find engagement opportunities
  async findEngagementOpportunities(): Promise<EngagementOpportunity[]> {
    const opportunities: EngagementOpportunity[] = []

    try {
      logger.info('üîç Step 1: Finding unanswered questions...')
      const unansweredQuestions = await this.findUnansweredQuestions()
      logger.info(`üìù Found ${unansweredQuestions.length} unanswered questions`)
      opportunities.push(...unansweredQuestions)

      logger.info('üîç Step 2: Finding trending opportunities...')
      const trendingOpportunities = await this.findTrendingOpportunities()
      logger.info(`üìà Found ${trendingOpportunities.length} trending opportunities`)
      opportunities.push(...trendingOpportunities)

      logger.info('üîç Step 3: Finding collaboration opportunities...')
      const collaborationOpportunities = await this.findCollaborationOpportunities()
      logger.info(`ü§ù Found ${collaborationOpportunities.length} collaboration opportunities`)
      opportunities.push(...collaborationOpportunities)

      logger.info('üîç Step 4: Finding learning opportunities...')
      const learningOpportunities = await this.findLearningOpportunities()
      logger.info(`üìö Found ${learningOpportunities.length} learning opportunities`)
      opportunities.push(...learningOpportunities)

      // Sort by priority
      const sortedOpportunities = opportunities.sort((a, b) => {
        const priorityOrder = { high: 3, medium: 2, low: 1 }
        return priorityOrder[b.priority] - priorityOrder[a.priority]
      })

      logger.info(`üìä Total opportunities found: ${sortedOpportunities.length}`)
      return sortedOpportunities

    } catch (error) {
      logger.error('üí• Error finding engagement opportunities:', error)
      logger.error('Stack trace:', error.stack)
      return []
    }
  }

  // Find unanswered questions
  private async findUnansweredQuestions(): Promise<EngagementOpportunity[]> {
    try {
      logger.info('üìã Querying database for unanswered questions...')
      const questions = await databaseService.getQuestions({ 
        sortBy: 'unanswered',
        limit: 50 
      })

      logger.info(`üìä Database returned ${questions.length} questions`)
      questions.forEach((q, index) => {
        logger.info(`  ${index + 1}. "${q.title}" - answers: ${q.answers_count || 0}, is_ai: ${q.is_ai_generated}`)
      })

      const filteredQuestions = questions.filter(q => {
        const hasNoAnswers = !q.answers_count || q.answers_count === 0
        const isNotAI = !q.is_ai_generated
        logger.info(`  Filtering "${q.title}": hasNoAnswers=${hasNoAnswers}, isNotAI=${isNotAI}`)
        return hasNoAnswers && isNotAI
      })

      logger.info(`‚úÖ After filtering: ${filteredQuestions.length} unanswered human questions`)

      const opportunities = filteredQuestions
        .slice(0, 3) // Limit to 3 opportunities
        .map(question => {
          const priority = this.calculateQuestionPriority(question)
          const persona = this.selectPersonaForQuestion(question)
          logger.info(`üìù Creating opportunity for "${question.title}" with priority ${priority} and persona ${persona}`)
          
          return {
            type: 'unanswered_question' as const,
            priority,
            targetId: question.id,
            context: question,
            suggestedPersona: persona,
            reason: `Unanswered question: "${question.title}"`
          }
        })

      logger.info(`üéØ Created ${opportunities.length} unanswered question opportunities`)
      return opportunities

    } catch (error) {
      logger.error('üí• Error finding unanswered questions:', error)
      logger.error('Stack trace:', error.stack)
      return []
    }
  }

  // Find trending opportunities
  private async findTrendingOpportunities(): Promise<EngagementOpportunity[]> {
    try {
      logger.info('üìà Looking for trending topics...')
      const trendingTopics = this.stats.trendingTopics.filter(t => t.frequency > 2)
      
      logger.info(`üìä Found ${trendingTopics.length} trending topics`)
      trendingTopics.forEach(topic => {
        logger.info(`  - ${topic.topic} (frequency: ${topic.frequency})`)
      })

      return trendingTopics.slice(0, 2).map(topic => ({
        type: 'trending_topic' as const,
        priority: 'medium' as const,
        targetId: topic.topic,
        context: { topic: topic.topic },
        suggestedPersona: 'proto-bot-alex',
        reason: `Trending topic: ${topic.topic}`
      }))

    } catch (error) {
      logger.error('üí• Error finding trending opportunities:', error)
      return []
    }
  }

  // Find collaboration opportunities
  private async findCollaborationOpportunities(): Promise<EngagementOpportunity[]> {
    try {
      logger.info('ü§ù Looking for collaboration opportunities...')
      // Placeholder for now
      return []
    } catch (error) {
      logger.error('üí• Error finding collaboration opportunities:', error)
      return []
    }
  }

  // Find learning opportunities
  private async findLearningOpportunities(): Promise<EngagementOpportunity[]> {
    try {
      logger.info('üìö Looking for learning opportunities...')
      // Placeholder for now
      return []
    } catch (error) {
      logger.error('üí• Error finding learning opportunities:', error)
      return []
    }
  }

  // Execute engagement opportunity
  async executeEngagement(opportunity: EngagementOpportunity): Promise<void> {
    try {
      logger.info(`üöÄ Executing ${opportunity.type} engagement for target ${opportunity.targetId}`)
      let engagement: any = null

      switch (opportunity.type) {
        case 'unanswered_question':
          logger.info('üí¨ Engaging with unanswered question...')
          engagement = await this.engageWithQuestion(opportunity)
          break
        case 'trending_topic':
          logger.info('üìà Engaging with trending topic...')
          engagement = await this.engageWithTrendingTopic(opportunity)
          break
        case 'collaboration_request':
          logger.info('ü§ù Engaging with collaboration request...')
          engagement = await this.engageWithCollaboration(opportunity)
          break
        case 'learning_opportunity':
          logger.info('üìö Engaging with learning opportunity...')
          engagement = await this.engageWithLearning(opportunity)
          break
        default:
          logger.error(`‚ùå Unknown engagement type: ${opportunity.type}`)
          return
      }

      if (engagement) {
        logger.info('‚úÖ Engagement successful, recording...')
        await this.recordEngagement(opportunity, engagement)
        this.stats.successfulEngagements++
        this.stats.lastEngagement = new Date()
        logger.info(`üéâ Successfully executed ${opportunity.type} engagement`)
      } else {
        logger.warn(`‚ö†Ô∏è No engagement generated for ${opportunity.type}`)
      }

    } catch (error) {
      logger.error(`üí• Error executing engagement ${opportunity.type}:`, error)
      logger.error('Stack trace:', error.stack)
      this.stats.failedEngagements++
    }
  }

  // Engage with unanswered question
  private async engageWithQuestion(opportunity: EngagementOpportunity): Promise<any> {
    try {
      const question = opportunity.context
      logger.info(`üí¨ Generating AI response for question: "${question.title}"`)
      logger.info(`üìù Question content: "${question.content}"`)
      logger.info(`üè∑Ô∏è Question tags: ${JSON.stringify(question.tags)}`)
      
      // Create context for AI response
      const context = {
        questionId: question.id,
        questionContent: question.content,
        questionAuthor: question.author_id,
        previousResponses: [],
        communityTrends: this.stats.trendingTopics.map(t => t.topic),
        userInterests: [],
        conversationHistory: []
      }

      logger.info('ü§ñ Calling AI community member service to generate response...')
      const aiResponse = await aiCommunityMemberService.generateResponse(question, context)
      
      if (aiResponse) {
        logger.info(`‚úÖ AI response generated successfully`)
        logger.info(`üë§ Persona: ${aiResponse.persona?.name}`)
        logger.info(`üìù Content length: ${aiResponse.content?.length || 0} characters`)
        logger.info(`üéØ Confidence: ${aiResponse.confidence}`)

        // Create answer in database
        logger.info('üíæ Creating answer in database...')
        const answerData = {
          question_id: question.id,
          content: aiResponse.content,
          author_id: aiResponse.authorId,
          is_ai: true,
          metadata: {
            persona: aiResponse.persona?.name,
            confidence: aiResponse.confidence,
            emotionalTone: aiResponse.emotionalTone,
            followUpQuestions: aiResponse.followUpQuestions,
            engagementType: 'unanswered_question'
          }
        }

        logger.info(`üìä Answer data: ${JSON.stringify(answerData, null, 2)}`)
        
        const createdAnswer = await databaseService.createAnswer(answerData)
        logger.info(`‚úÖ Answer created successfully with ID: ${createdAnswer?.id}`)

        return aiResponse
      } else {
        logger.warn('‚ö†Ô∏è AI response generation returned null')
        return null
      }

    } catch (error) {
      logger.error('üí• Error engaging with question:', error)
      logger.error('Stack trace:', error.stack)
      return null
    }
  }

  // Engage with trending topic
  private async engageWithTrendingTopic(opportunity: EngagementOpportunity): Promise<any> {
    try {
      const topic = opportunity.context.topic
      logger.info(`üìà Generating proactive engagement for trending topic: ${topic}`)
      
      // Generate proactive engagement about the trending topic
      const engagement = await aiCommunityMemberService.generateProactiveEngagement()
      
      if (engagement) {
        logger.info('‚úÖ Proactive engagement generated, creating question...')
        // Create a question about the trending topic
        const question = await databaseService.createQuestion({
          title: `Discussion: ${topic}`,
          content: engagement.content,
          tags: [topic, 'trending', 'discussion'],
          author_id: engagement.authorId,
          is_ai_generated: true,
          metadata: {
            engagementType: 'trending_topic',
            originalTopic: topic
          }
        })

        logger.info(`‚úÖ Trending topic question created with ID: ${question?.id}`)
        return { question, engagement }
      }

      return null
    } catch (error) {
      logger.error('üí• Error engaging with trending topic:', error)
      return null
    }
  }

  // Engage with collaboration request
  private async engageWithCollaboration(opportunity: EngagementOpportunity): Promise<any> {
    logger.info('ü§ù Collaboration engagement not implemented yet')
    return null
  }

  // Engage with learning opportunity
  private async engageWithLearning(opportunity: EngagementOpportunity): Promise<any> {
    logger.info('üìö Learning engagement not implemented yet')
    return null
  }

  // Record engagement in history
  private async recordEngagement(opportunity: EngagementOpportunity, engagement: any): Promise<void> {
    try {
      const record = {
        timestamp: new Date().toISOString(),
        type: opportunity.type,
        priority: opportunity.priority,
        targetId: opportunity.targetId,
        persona: engagement.persona?.name || 'unknown',
        success: true
      }

      this.engagementHistory.push(record)
      this.stats.totalEngagements++

      logger.info(`üìù Recorded engagement: ${JSON.stringify(record)}`)

      // Keep only last 100 engagements
      if (this.engagementHistory.length > 100) {
        this.engagementHistory = this.engagementHistory.slice(-100)
      }
    } catch (error) {
      logger.error('üí• Error recording engagement:', error)
    }
  }

  // Analyze community trends
  async analyzeCommunityTrends(): Promise<void> {
    try {
      logger.info('üìä Analyzing community trends...')
      // Placeholder implementation
      this.stats.trendingTopics = [
        { topic: 'prototyping', frequency: 5, sentiment: 'positive', trendingUp: true, relatedQuestions: [] },
        { topic: 'validation', frequency: 3, sentiment: 'neutral', trendingUp: true, relatedQuestions: [] }
      ]
      logger.info(`‚úÖ Community trends updated: ${this.stats.trendingTopics.length} topics`)
    } catch (error) {
      logger.error('üí• Error analyzing community trends:', error)
    }
  }

  // Update community health score
  async updateCommunityHealth(): Promise<void> {
    try {
      logger.info('‚ù§Ô∏è Updating community health score...')
      // Simple health calculation based on engagement
      const healthScore = Math.min(100, (this.stats.successfulEngagements / Math.max(1, this.stats.totalEngagements)) * 100)
      this.stats.communityHealth = healthScore
      logger.info(`‚úÖ Community health updated: ${healthScore}%`)
    } catch (error) {
      logger.error('üí• Error updating community health:', error)
    }
  }

  // Helper methods
  private canEngage(): boolean {
    const recentCount = this.getRecentEngagementsCount()
    return recentCount < this.config.maxEngagementsPerHour
  }

  private getRecentEngagementsCount(): number {
    const now = new Date()
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000)
    
    return this.engagementHistory.filter(
      e => new Date(e.timestamp) > oneHourAgo
    ).length
  }

  private calculateQuestionPriority(question: any): 'high' | 'medium' | 'low' {
    // Higher priority for questions with certain tags or recent activity
    if (question.tags?.includes('urgent') || question.tags?.includes('help')) return 'high'
    if (question.views > 5 || question.tags?.includes('prototyping')) return 'medium'
    return 'low'
  }

  private selectPersonaForQuestion(question: any): string {
    // Simple persona selection based on tags
    if (question.tags?.includes('design')) return 'proto-bot-maya'
    if (question.tags?.includes('technical') || question.tags?.includes('development')) return 'proto-bot-jordan'
    if (question.tags?.includes('validation') || question.tags?.includes('research')) return 'proto-bot-sam'
    return 'proto-bot-alex' // Default to Alex
  }

  // Public methods for monitoring and control
  getStats(): MonitoringStats {
    return { ...this.stats }
  }

  getConfig(): MonitoringConfig {
    return { ...this.config }
  }

  updateConfig(newConfig: Partial<MonitoringConfig>): void {
    this.config = { ...this.config, ...newConfig }
    logger.info('üìù Monitoring configuration updated')
  }

  getEngagementHistory(): any[] {
    return [...this.engagementHistory]
  }

  async forceEngagement(): Promise<void> {
    logger.info('üöÄ Forcing immediate engagement...')
    await this.processEngagementOpportunities()
  }

  async forceAnalysis(): Promise<void> {
    logger.info('üìä Forcing immediate community analysis...')
    await this.analyzeCommunityTrends()
    await this.updateCommunityHealth()
  }
}

// Export singleton instance
export const aiMonitoringService = new AIMonitoringService()

// Export the class for testing
export { AIMonitoringService }
